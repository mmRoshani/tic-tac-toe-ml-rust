mod engine;

slint::include_modules!();

fn main() -> Result<(), slint::PlatformError> {
    let ui = AppWindow::new()?;
    // let ui_handle = ui.as_weak();

    let mut board = engine::ml::Board::new();

    ui.on_play(move |button_num: i32| {
        // let ui = ui_handle.unwrap();
        

        match button_num {
            0 => {
                movemnt(&mut board, 0, 0);
            },
            1 => {
                movemnt(&mut board, 0, 1);
            },
            2 => {        
                movemnt(&mut board, 0, 2);
            },  
            3 => {              
                movemnt(&mut board,1 , 0);
            },
            4 => { 
                movemnt(&mut board,1 , 1);
            },
            5 => {
                movemnt(&mut board,1 , 2);
            },
            6 => { 
                movemnt(&mut board,2 , 0);
            },
            7 => { 
                movemnt(&mut board,2 , 1);
            },
            8 => {
                movemnt(&mut board,2 , 2);
            },
            _ => println!("{}", "Unsupported case"),
        }
    });

    ui.run()
}

fn movemnt(board: &mut engine::ml::Board, row: usize, col: usize) {
    println!("board score is {}", board.board_state());

    // mage 'x's and 'o's
    let _move_counter = board.game_progress();
    let mut sign: Option<char>; 

    if _move_counter % 2 == 0
    {
        sign = Some('X');   
        board.state[row][col] = sign;
    }
    else
    {
        sign = Some('O');

let mut best_v = -std::i32::MAX;
let mut best_move = None;

                    for (ni, nj) in neighbors(i, j) {
                        let v = board.state[ni][nj].v();  // Assuming `v` is a method of the cell state
                        if v > best_v {
                            best_v = v;
                            best_move = Some((ni, nj));
                        }
                    }

    }

    board.moves_played = _move_counter + 1;

    let approximation_val = board.v();
    
    println!("function approximatiomn for {} is {}", row + col, approximation_val);
}

fn neighbors(i: usize, j: usize) -> Vec<(usize, usize)> {
    let directions = [
        (-1, -1), (-1, 0), (-1, 1),
        (0, -1),           (0, 1),
        (1, -1), (1, 0), (1, 1),
    ];

    let mut neighbors = Vec::new();

    for (di, dj) in &directions {
        let ni = i as i32 + di;
        let nj = j as i32 + dj;

        if ni >= 0 && nj >= 0 && ni < 3 && nj < 3 {
            neighbors.push((ni as usize, nj as usize));
        }
    }

    neighbors
}
